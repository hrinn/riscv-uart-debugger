\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage[hidelinks]{hyperref}
\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}

\title{Pipeline control protocol}
\author{Trevor McKay}
\date{Summer 2020}

\graphicspath{{./figures/}}

\begin{document}

\begin{center}
    \Large\textbf{Pipeline debug controller protocol}
\end{center}

\section{Overview}

This protocol aims to make hardware add-ons and software for the Otter easier to develop. Control flow operations
allow for easy manipulation of the state of the pipeline as well as many low-level operations such
as memory and register editing, pause, or resume. The module is designed for use with a debugger and
contains internal logic for this purpose. Fortunately, all debugging operations from polling memory
to breakpoints can be implemented with functions or series of functions added by implementing this
protocol. The controller (contains all of the outputs shown in the diagram below except the serial
connection) and debugger serial decoder (translates serial data to debugging commands) are two
submodules grouped together in one module. Since the HDL code makes distinctions between these modules,
it is possible and encouraged to use the controller for other purposes. However, this document
describes the protocol and implementation in the context of the debugger.

\medskip
\noindent\underline{\href{https://github.com/trmckay/pipeline-debugger}{GitHub repository for the pipeline debugger}}

\section{Connections}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{pipeline_db}
\end{figure}
\medskip

The module connects to the MCU, register file, and memory. Commands are recieved via serial and
decoded within the module. Both \emph{srx} and \emph{stx} can be ignored initially. The signals \emph{rf\_wr, rf\_rd, addr,} and
\emph{d\_in} connect to the register file for reads and writes. The \emph{mem\_wr}, \emph{mem\_rd},
\emph{addr}, and \emph{d\_in} connect to the memory or memory hub for reads and writes. Finally,
\emph{resume, pause}, and \emph{reset} control the flow of the pipeline. The \emph{valid} signal
determines wether or not the controller is issuing a command.

\newpage
\section{Protocol}

It can be assumed that reads, writes, and resumes will only be issued while the MCU is paused. It
can also be assumed that only one command will occur at any time. If any two commands are issued at the
same time, it may be helpful to set \emph{error} and perhaps even do some error handling.

\begin{enumerate}

    \item\textbf{valid}\\
    Indicates that the debugger is issuing a command. The MCU should respond accordingly on the next positive clock edge.
    The control signals except \emph{ready} will hold until \emph{mcu\_busy} goes low.

    \item\textbf{resume}\\
    The MCU should resume normal operation. If this takes more than one cycle, keep \emph{mcu\_busy
    }high to indicate this.

    \item\textbf{pause}\\
    The MCU should appear to stop execution after the current instruction completes. The
    \emph{mcu\_busy} signal should be high from the next positive edge until the pipeline is
    completely paused. This should be implemented by pausing the PC so that it does not increment
    on the next positive edge and by squashing any susequent instructions. Additionally, the pipeline
    must be flushed such that all instructions in the pipeline when the \emph{pause} was
    issued are completed. When this is done, \emph{mcu\_busy} should go low. The MCU is now in a
    state where external modules can interface with the processor without interfering with
    program execution.

        \begin{verbatim}
                 clk:  __|¯¯|__|¯¯|__|¯¯|__|¯¯|__|¯¯|__|¯¯

                  pc:    0x04  0x08  0x0C  0x0C  0x0C  0x0C

            mcu_busy:  ______________|¯¯¯¯¯¯¯¯¯¯¯¯¯¯|_____

               pause:  ___________|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|_____

               valid:  _____________|¯|___________________
        \end{verbatim}

    \item\textbf{reset}\\
    The program counter should be set to zero. It is worth noting that this only resets the position of
    execution, not the contents of memory. Clearing can be optionally implemented by
    pausing the MCU while writing zeros to the entire memory, only resetting the PC when done.

    \item\textbf{mem\_rd}\\
    The MCU should read the memory at \emph{addr}. The \emph{mcu\_busy} should go
     high at or before the next positive clock edge until the memory read is complete. The
    controller will attempt to read the data \emph{d\_rd} on the first positive clock edge that
    \emph{mcu\_busy} is low. If the address is out of range, set \emph{error} to high.

        \begin{verbatim}
                 clk:  __|¯¯|__|¯¯|__|¯¯|__|¯¯|__|¯¯|__|¯¯

                  pc:  <_____________ 0x0C ______________>

            mcu_busy:  ________|¯¯¯¯¯¯¯¯¯¯¯¯¯¯|___________

                d_rd:  <______ Z ____________><__ 0x17 __>

              mem_rd:  _______|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|___________

               valid:  _______|¯|_________________________
        \end{verbatim}

    \newpage
    \item\textbf{mem\_wr}\\
    The MCU should write the data \emph{d\_in} to the memory at \emph{addr}. The \emph{mcu\_busy} should go
    high at or before the next positive clock edge until the memory write is complete.
    If the address is out of range, do nothing.

        \begin{verbatim}
                 clk:  __|¯¯|__|¯¯|__|¯¯|__|¯¯|__|¯¯|__|¯¯

                  pc:  <____________ 0x0C _______________>

            mcu_busy:  ______________|¯¯¯¯¯¯|_____________

                d_in:  <_________ 0x17 __________><_ Z __>

              mem_wr:  _____________|¯¯¯¯¯¯¯¯¯¯¯¯|________

               valid:  _____________|¯|___________________
        \end{verbatim}

    \item\textbf{rf\_rd}\\
    The MCU should read the register file at \emph{addr}. The \emph{mcu\_busy} signal should go
    high at or before the next positive clock edge until the read is complete. However, it is
    likely that the register file supports asynchronous reads and that \emph{mcu\_busy} never
    needs to go high. The controller will attempt to read the data \emph{d\_rd} on the first positive clock edge that
    \emph{mcu\_busy} is low. In the case of the register file, this will likely be very the next
    cycle. If the address is out of range, set \emph{error} to high. See the waveforms of
    \emph{mem\_rd} for multicycle read examples.

        \begin{verbatim}
                 clk:  __|¯¯|__|¯¯|__|¯¯|__|¯¯|__|¯¯|__|¯¯

                  pc:  <____________ 0x0C _______________>

            mcu_busy:  ___________________________________

                d_rd:  <_____ Z ____><______ 0x17 _______>

              reg_rd:  _____________|¯¯¯¯¯¯|______________

               valid:  _____________|¯|___________________
        \end{verbatim}

    \item\textbf{rf\_wr}\\
    The MCU should write the data \emph{d\_in} to the memory at \emph{addr}. The \emph{mcu\_busy} should go
    high at or before the next positive clock edge until the memory write is complete. This should
    only take one cycle for the register file; if so, \emph{mcu\_busy} does not need to be high.
    If the address is out of range, set \emph{error} to high.

        \begin{verbatim}
                 clk:  __|¯¯|__|¯¯|__|¯¯|__|¯¯|__|¯¯|__|¯¯

                  pc:  <_____________ 0x0C ______________>

            mcu_busy:  ___________________________________

                d_in:  <________ 0x17 _____><_____ Z ____> 

              reg_wr:  _____________|¯¯¯¯¯¯|______________

               valid:  _____________|¯|___________________
        \end{verbatim}

\end{enumerate}

\newpage
\section{Implementation suggestions}
There is no right or wrong way to implement this protocol, as long as the MCU responds correctly.
However, there are some ways to make this easier.

Firstly, give your pipeline the ability to flush
outside of just the \emph{pause} signal. In other words, have a \emph{flush} signal internal to the
MCU that can be activated at discretion. Not only does it better decompose the control operations,
but it can be useful to have this for interrupts.

Additionally, have a register in the pipeline keep track of whether the pipeline is performing an
operation. Quickly being able to determine this by looking at a single register
will make it easier to MUX between the pipeline's internal inputs and the controller's inputs for
the memory and register file. The controller will hold signals except for \emph{valid}, so it is not
necessary to keep track of the type of operation.

\vspace*{\fill}
\begin{center}
    \noindent Contact Trevor McKay with questions.\\
    \href{mailto:trs.mckay@gmail.com}{trs.mckay@gmail.com}
\end{center}

\end{document}
